from datetime import datetime
from collections import namedtuple
import re


from aiogopro.types import CommandType, StatusType

RESERVED_WORDS = ['type', 'class']
T1 = ' ' * 4
T2 = T1 * 2
T3 = T1 * 3
T4 = T1 * 4


SUBMODE_PREFIX = {
    'resolution': 'res_',
    'aspect_ratio': 'aspect_',
    'fps': 'Fps_',
    'looping': 'Time_',
    'protune_white_balance': 'color_',
    'protune_iso': 'iso_',
    'protune_iso_min': 'iso_',
    'protune_exposure_time': 'time_',
    'capture_delay': 'delay_',
    'burst_rate': 'rate_',
    'timelapse_rate': 'rate_',
    'nightlapse_rate': 'rate_',
    'short_clip_length': 'length_',
    'protune_ev': 'ev_',
    'timewarp_speed': 'speed_',
    'exposure_time': 'time_',
    'record_resolution': 'r_',
    'record_fps': 'fps_',
    'window_size': 'size_',
    'bit_rate': 'rate_',
    'lcd_sleep': 'sleep_',
    'auto_power_down': 'off_',
    'gop_size': 'size_',
    'idr_interval': 'interval_',
    'stream_bit_rate': 'rate_',
    'stream_window_size': 'size_',
    'stream_gop_size': 'size_',
    'stream_idr_interval': 'interval_',
    'lcd_brightness_v2': 'percent_'
}

rx_replace1 = re.compile(r'([\.])')
rx_replace2 = re.compile(r'([_]{2,})')
rx_remove = re.compile(r'([%])')


def filterbyvalue(seq, value):
    for el in seq:
        if el.attribute == value:
            yield el


def dictToObject(d, name):
    if not isinstance(d, dict):
        return d
    for k, v in d.copy().items():
        if isinstance(v, dict):
            d[k] = dictToObject(v, f"{capitalize(k)}Type")
        elif isinstance(v, list):
            d[k] = list(map(lambda x: dictToObject(x, f"{capitalize(k)}List"), v))
    return namedtuple(name, d.keys())(*d.values())


def pythonify(text):
    s = str(text).lower().replace(' ', '_')
    s = s.replace('-', '_neg_').replace('+', '_plus_')
    s = s.replace(':', 'to')  # a ratio is always TO
    s = s.replace('/', '_in_')
    s = rx_remove.sub('', s)
    s = rx_replace1.sub('_', s)
    s = rx_replace2.sub('_', s)
    return s


def capitalize(text):
    s = str(text).replace(' ', '_').split('_')
    regex = re.compile(r'([\/:])')
    for index in range(len(s)):
        s[index] = regex.sub('_', s[index]).capitalize()
        s[index] = s[index].replace('.', '').replace('-', 'Neg').replace('%', '')
    return ''.join(s)


def prefix_reserved(value, prefix):
    if value in RESERVED_WORDS:
        return f'{prefix}_{value}'
    return value


class SchemaType(object):
    def __init__(self, schema_version, version):
        self.schema_version = schema_version
        self.version = version
        self.commands = {}
        self.modes = {}
        self.status = {}

    def addCommand(self, cmd):
        if 'wifi' not in cmd['network_types']:
            return

        key = cmd['key']
        self.commands[key] = CommandType(
            key,
            cmd['url'],
            cmd['widget_type'],
            cmd['display_name']
        )

    def addMode(self, mode):
        key = mode['path_segment']
        self.modes[key] = dictToObject(mode, 'ModeType')

    def addStatus(self, groupname, field):
        group = self.status.get(groupname, {})
        group[field['name']] = StatusType(**field)

        self.status[groupname] = group

    @staticmethod
    def parse(data):
        parser = SchemaType(data['schema_version'], data['version'])
        for cmd in data['commands']:
            parser.addCommand(cmd)

        if data['modes']:
            for mode in data['modes']:
                parser.addMode(mode)

        for group in data['status']['groups']:
            for field in group['fields']:
                parser.addStatus(group['group'], field)

        return parser


def schema_pythonify(schema, filename):
    header = [
        f'# Autogenerated by {__name__}.schema_pythonify at {datetime.now()}\n'
    ]

    types = []

    # Status options
    types.append('StatusType')
    status = ['\n\n']
    status.append('class Status(object):')
    extra = ''
    for groupname in schema.status.keys():
        status.append(f'{extra}    class {capitalize(groupname)}(object):')
        for key, field in schema.status[groupname].items():
            status.append(f'        {prefix_reserved(field.name, groupname)} = StatusType("{field.name}", {field.id})')
        extra = '\n'

    # Commands
    types.append('CommandType')
    command = ['\n\n']
    extra = False
    command.append('class Command(object):')
    for key, cmd in schema.commands.items():
        if extra:
            command.append('')
        extra = True
        command.append('    {0} = CommandType(\n        "{0}",\n        "{1}",\n        "{2}",\n        "{3}")'.format(
            cmd.name,
            cmd.url,
            cmd.widget,
            cmd.display_name
        ))

    # Modes
    # types.append('ModeType')
    mode = ['\n\n']
    othermode = []
    extra = False
    mode.append('class Mode(Enum):')
    submode = [f'\n\nclass SubMode(object):']
    for k, v in schema.modes.items():
        mode.append(f"{T1}{pythonify(k)} = '{v.value}'")
        if v.settings:
            # default settings
            defaults = [x for x in v.settings if x.path_segment == 'default_sub_mode']
            if len(defaults) > 0:
                submode.append(f"\n{T1}class {capitalize(k)}(Enum):")
            for sm in defaults:
                prefix = ''
                if sm.path_segment in SUBMODE_PREFIX:
                    prefix = SUBMODE_PREFIX[sm.path_segment]
                for o in sm.options:
                    submode.append(f"{T2}{pythonify(prefix + o.display_name)} = '{o.value}'")

            # non default settings
            others = [x for x in v.settings if x.path_segment != 'default_sub_mode']
            if len(others) > 0:
                othermode.append(f'\n\nclass {capitalize(k)}(object):')
                for sm in others:
                    othermode.append(f"\n{T1}{capitalize(sm.path_segment).upper()} = '{sm.id}'")
                    othermode.append(f"\n{T1}class {capitalize(sm.path_segment)}(Enum):")
                    prefix = ''
                    if sm.path_segment in SUBMODE_PREFIX:
                        prefix = SUBMODE_PREFIX[sm.path_segment]
                    for o in sm.options:
                        othermode.append(f"{T2}{pythonify(prefix + o.display_name)} = '{o.value}'")

    mode = mode + submode + othermode

    # finalize
    lines = []
    header.append("from enum import Enum")
    header.append("from aiogopro.types import {0}".format(", ".join(types)))
    lines.append("\n".join(header))
    lines.append("\n".join(status))
    lines.append("\n".join(command))
    lines.append("\n".join(mode))

    lines.append("\n")
    with open(filename, 'w') as f:
        f.writelines(lines)


def command_compare(firsts, seconds, firstname='first', secondname='second'):
    for key, cmdA in firsts.items():
        if key in seconds:
            cmdB = seconds[key]
            if cmdA.url != cmdB.url:
                print("Same command {0} different url {1} != {2} ({3}/{4})".format(cmdA.url, cmdB.url, firstname, secondname))
        else:
            print('Only in {2}, Command {0}: {1}'.format(cmdA.name.ljust(47), cmdA.display_name, firstname))


def mode_compare(firsts, seconds, firstname='first', secondname='last'):
    for key, modeA in firsts.items():
        if key in seconds:
            modeB = seconds[key]
            if (modeA.value != modeB.value):
                print("Same mode {0} different value {1} != {2} ({3}/{4})".format(modeA.value, modeB.value, firstname, secondname))
        else:
            print('Only in {2}, Mode {0}: {1}'.format(modeA.name.ljust(20), modeA.display_name, firstname))


def status_compare(groupname, firsts, seconds, firstname='first', secondname='second'):
    for key, statusA in firsts.items():
        if key in seconds:
            statusB = seconds[key]
            if (statusA.id != statusB.id):
                print("Same status {0}.{1} different id {2} != {3} ({4}/{5})".format(
                    groupname, key, statusA.id, statusB.id, firstname, secondname))
        else:
            print('Only in {3}, Status {0}.{1}: {2}'.format(groupname, statusA.name.ljust(47), statusA.id, firstname))


def schema_compare(first, second, firstname='first', secondname='second'):
    command_compare(first.commands, second.commands, firstname, secondname)
    command_compare(second.commands, first.commands, secondname, firstname)
    mode_compare(first.modes, second.modes, firstname, secondname)
    mode_compare(second.modes, first.modes, secondname, firstname)

    for groupname in first.status.keys():
        status_compare(groupname, first.status[groupname], second.status, firstname, secondname)
        status_compare(groupname, second.status[groupname], first.status, secondname, firstname)
